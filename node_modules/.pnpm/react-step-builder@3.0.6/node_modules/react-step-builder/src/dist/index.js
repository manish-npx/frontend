"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useSteps = exports.StepsProvider = exports.Steps = void 0;

var React = _interopRequireWildcard(require("react"));

var StepsContext = /*#__PURE__*/React.createContext({
  current: 1,
  setCurrent: function setCurrent() {},
  size: 0,
  setSize: function setSize() {},
  isLast: false,
  isFirst: false,
  hasPrev: false,
  hasNext: false,
  progress: 0,
  next: function next() {},
  prev: function prev() {},
  jump: function jump() {}
});

var StepsProvider = function StepsProvider(_a) {
  var children = _a.children;

  var _b = React.useState(1),
      current = _b[0],
      setCurrent = _b[1];

  var _c = React.useState(0),
      size = _c[0],
      setSize = _c[1];

  var next = function next() {
    var nextStep = current + 1;
    nextStep <= size && setCurrent(nextStep);
  };

  var prev = function prev() {
    var prevStep = current - 1;
    prevStep >= 1 && setCurrent(prevStep);
  };

  var jump = function jump(step) {
    step >= 1 && step <= size && setCurrent(step);
  };

  var isLast = current === size;
  var isFirst = current === 1;
  var hasPrev = current > 1;
  var hasNext = current < size;
  var progress = Number(((current - 1) / (size - 1)).toFixed(2));
  var contextValue = {
    current: current,
    setCurrent: setCurrent,
    size: size,
    setSize: setSize,
    isLast: isLast,
    isFirst: isFirst,
    hasPrev: hasPrev,
    progress: progress,
    next: next,
    prev: prev,
    jump: jump,
    hasNext: hasNext
  };
  return /*#__PURE__*/React.createElement(StepsContext.Provider, {
    value: contextValue
  }, children);
};

exports.StepsProvider = StepsProvider;

var Steps = function Steps(props) {
  var stepsContext = React.useContext(StepsContext);
  var current = stepsContext.current,
      setCurrent = stepsContext.setCurrent,
      setSize = stepsContext.setSize;

  var _a = React.useState(true),
      isInitialRender = _a[0],
      setIsInitialRender = _a[1];

  React.useEffect(function () {
    setIsInitialRender(false);
    var _a = props.startsFrom,
        startsFrom = _a === void 0 ? 1 : _a;
    var size = React.Children.count(props.children);

    if (startsFrom > size) {
      setCurrent(1);
      console.warn("React Step Builder: startsFrom is greater than the number of steps. First step will be rendered by default.");
    } else {
      setCurrent(startsFrom);
    }
  }, []);
  React.useEffect(function () {
    var size = React.Children.count(props.children);
    setSize(size);
  }, [props.children]);
  React.useEffect(function () {
    var _a;

    !isInitialRender && ((_a = props.onStepChange) === null || _a === void 0 ? void 0 : _a.call(props));
  }, [current]);
  var steps = React.Children.map(props.children, function (child, index) {
    var step = index + 1;
    var stepsChild = /*#__PURE__*/React.cloneElement(child);
    return current === step && stepsChild;
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, steps);
};

exports.Steps = Steps;

var useSteps = function useSteps() {
  var stepsContext = React.useContext(StepsContext);
  var prev = stepsContext.prev,
      next = stepsContext.next,
      jump = stepsContext.jump,
      isFirst = stepsContext.isFirst,
      isLast = stepsContext.isLast,
      hasPrev = stepsContext.hasPrev,
      hasNext = stepsContext.hasNext,
      progress = stepsContext.progress,
      total = stepsContext.size,
      current = stepsContext.current;
  return {
    prev: prev,
    next: next,
    jump: jump,
    isFirst: isFirst,
    isLast: isLast,
    hasPrev: hasPrev,
    hasNext: hasNext,
    progress: progress,
    total: total,
    current: current
  };
};

exports.useSteps = useSteps;